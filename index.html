<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Roket Platformer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/inflate.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: black; font-family: 'Segoe UI', sans-serif; color: #fff; }
    canvas { display: block; }
    .hud {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 14px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      font-size: 14px;
      letter-spacing: 0.5px;
      pointer-events: none;
    }

    .joystick {
      display: none;
      position: fixed;
      bottom: 30px;
      right: 30px;
      left: auto;
      width: 140px;
      height: 140px;
      touch-action: none;
      user-select: none;
      z-index: 5;
    }
    body.show-joystick .joystick {
      display: block;
    }
    .joystick-base {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      backdrop-filter: blur(4px);
      position: relative;
    }
    .joystick-handle {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(77,198,255,0.45);
      border: 2px solid rgba(77,198,255,0.9);
      box-shadow: 0 0 14px rgba(77,198,255,0.6);
      transform: translate(calc(-50% + var(--offset-x, 0px)), calc(-50% + var(--offset-y, 0px)));
      transition: transform 0.12s ease;
    }

    @media (hover: none) and (pointer: coarse) {
      .joystick {
        display: block;
      }
    }

  </style>
</head>
<body>
<div class="hud">Gerakin joysticknya bray - tekan J di desktop buat munculin/sembunyiin</div>
<div class="joystick">
  <div class="joystick-base">
    <div class="joystick-handle"></div>
  </div>
</div>
<script>
  let scene, camera, renderer, rocket, stars, thruster, thrusterLight, thrusterParticles;
  const thrusterParticleData = [];
  const thrusterParticleCount = 170;
  const animatedModels = [];
  const orbitingModels = [];
  const namedModels = new Map();
  const pendingOrbitRegistrations = [];
  const orbitTempQuaternion = new THREE.Quaternion();
  const orbitTempVector = new THREE.Vector3();
  const orbitTempCenter = new THREE.Vector3();
  let thrusterParticleSpawnAccumulator = 0;
  let thrusterParticleTexture = null;
  let lastRocketUpdateTime = null;
  let lastFrameTime = performance.now();
  const gltfLoader = new THREE.GLTFLoader();
  const textureLoader = new THREE.TextureLoader();
  const fontLoader = new THREE.FontLoader();
  const fontCache = new Map();
  const defaultFontUrl = "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json";

  const coarsePointerQuery = typeof window !== "undefined" && typeof window.matchMedia === "function" ? window.matchMedia("(hover: none) and (pointer: coarse)") : null;
  let joystickManualOverride = null;
  let joystickAutoVisible = false;
  let joystickTouchActivated = false;

  function computeAutoJoystickVisibility() {
    if (coarsePointerQuery && coarsePointerQuery.matches) return true;
    if (typeof navigator !== "undefined") {
      if (typeof navigator.maxTouchPoints === "number" && navigator.maxTouchPoints > 0) return true;
      if (typeof navigator.msMaxTouchPoints === "number" && navigator.msMaxTouchPoints > 0) return true;
      const ua = navigator.userAgent || "";
      if (/(android|iphone|ipad|ipod|iemobile|webos|blackberry|bb10|playbook|opera mini|mobile)/i.test(ua)) return true;
    }
    if (typeof window !== "undefined" && ("ontouchstart" in window || ("DocumentTouch" in window && document instanceof window.DocumentTouch))) return true;
    return false;
  }

  function setJoystickVisibility(visible) {
    const currentlyVisible = document.body.classList.contains("show-joystick");
    if (visible && !currentlyVisible) {
      document.body.classList.add("show-joystick");
    } else if (!visible && currentlyVisible) {
      document.body.classList.remove("show-joystick");
      resetJoystick();
    }
  }

  function updateAutoJoystickVisibility() {
    joystickAutoVisible = computeAutoJoystickVisibility();
    if (joystickManualOverride === null) {
      setJoystickVisibility(joystickAutoVisible);
    }
  }

  function handleFirstTouch() {
    joystickTouchActivated = true;
    if (joystickManualOverride === null) {
      joystickManualOverride = true;
      setJoystickVisibility(true);
    }
  }

  if (coarsePointerQuery) {
    const listener = () => updateAutoJoystickVisibility();
    if (typeof coarsePointerQuery.addEventListener === "function") {
      coarsePointerQuery.addEventListener("change", listener);
    } else if (typeof coarsePointerQuery.addListener === "function") {
      coarsePointerQuery.addListener(listener);
    }
  }

  if (typeof window !== "undefined") {
    window.addEventListener("resize", updateAutoJoystickVisibility);
    window.addEventListener("orientationchange", updateAutoJoystickVisibility);
    const firstTouchListener = () => {
      handleFirstTouch();
      window.removeEventListener("touchstart", firstTouchListener, false);
    };
    window.addEventListener("touchstart", firstTouchListener, false);
  }

  updateAutoJoystickVisibility();

  const modelConfigs = [
    // type optional, otomatis ditebak dari ekstensi file kalau tidak diisi
    // Gunakan rotate: { enabled: true, axis: { x:0, y:1, z:0 }, speed: 15 } untuk animasi putar kustom
    // Gunakan orbit: { enabled: true, targetName: "earth", radius: 260, height: 60, speed: 20, faceTarget: true } untuk membuat objek mengelilingi target
    {
      name: "earth",
      url: "models/earth.glb",
      center: true,
      scale: 500,
      position: { x: -70, y: -8, z: -90 },
      rotation: { x: 0, y: 0, z: 0 },
      castShadow: true,
      receiveShadow: true,
      rotate: {
        enabled: true,
        axis: { x: 0, y: 1, z: 0 },
        speed: 8
      },
      light: {
        type: "point",
        color: 0xaee0ff,
        intensity: 1.6,
        distance: 520,
        decay: 1.8,
        offset: { x: 0, y: 130, z: 40 }
      },
      onLoad: model => {
        const bbox = new THREE.Box3().setFromObject(model);
        const size = bbox.getSize(new THREE.Vector3());
        console.log("models/earth.glb loaded", { size, position: model.position.clone() });
      }
    },
    {
      name: "mars",
      url: "models/mars.glb",
      center: true,
      scale: 1,
      position: { x: -200, y: 0, z: 0 },
      castShadow: true,
      receiveShadow: true,
      rotate: {
        enabled: true,
        axis: { x: 0, y: 1, z: 0 },
        speed: 6
      },
      light: {
        type: "point",
        color: 0xffccb0,
        intensity: 1.4,
        distance: 420,
        decay: 1.9,
        offset: { x: -10, y: 95, z: 25 }
      }
    },
    {
      name: "jupiter",
      url: "models/jupiter.glb",
      center: true,
      scale: 0.0001,
      position: { x: 200, y: 0, z: 0 },
      castShadow: true,
      receiveShadow: true,
      rotate: {
        enabled: true,
        axis: { x: 0, y: 1, z: 0 },
        speed: 12
      },
      light: {
        type: "point",
        color: 0xfff2ce,
        intensity: 2.1,
        distance: 720,
        decay: 2,
        offset: { x: -20, y: 170, z: 60 }
      }
    },
    {
      name: "asteroid",
      url: "models/asteroid.glb",
      center: true,
      scale: 2,
      position: { x: 100, y: 0, z: 0 },
      rotate: {
        enabled: true,
        axis: { x: 0.3, y: 0.9, z: 0.2 },
        speed: 18
      },
      light: {
        type: "point",
        color: 0xdde9ff,
        intensity: 1.25,
        distance: 260,
        decay: 2,
        offset: { x: 0, y: 80, z: 0 }
      }
    },
    {
      name: "satellite",
      url: "models/satellite.glb",
      center: true,
      scale: 7,
      position: { x: -62, y: 42, z: -90 },
      castShadow: true,
      receiveShadow: true,
      light: {
        type: "point",
        color: 0xb2e0ff,
        intensity: 1.6,
        distance: 360,
        decay: 1.7,
        offset: { x: 0, y: 90, z: 30 }
      },
      orbit: {
        enabled: true,
        targetName: "earth",
        radius: 32,
        height: 24,
        speed: 38,
        startAngle: 12,
        axis: { x: 0, y: 1, z: 0 },
        faceTarget: true
      }
    }
    // {
    //   url: "models/direction_arrow.glb", 
    //   center: false,
    //   scale: 5,
    //   position: { x: 0, y: 0, z: 0 },
    //   rotation: { x: 90, y: 0, z: 0 },
    //   castShadow: true,
    //   receiveShadow: true,
    // },
    // {
    //   url: "models/direction_arrow.glb",
    //   center: true,
    //   scale: 5,
    //   position: { x: -80, y: 0, z: 0 },
    //   rotation: { x: 90, y: 0, z: 180 },
    //   castShadow: true,
    //   receiveShadow: true,
    // },
  ];

  const imageConfigs = [
    // { url: "BimaJPG.jpg", position: { x: 20, y: 12, z: 0 }, width: 15 }
  ];

  const textConfigs = [
    // Example: { text: "Hello", fontUrl: "fonts/helvetiker_regular.typeface.json", position: { x: -10, y: 25, z: 0 }, size: 6, height: 1, color: 0xffd166, collidable: true, reactive: true }
    // { text: "Hello Saya Bima Sakti Aditya", position: { x: 0, y: 0, z: 0 }, color: "#ffd166" }
  ];

  const boxConfigs = [
    // { size: { x: 20, y: 6, z: 10 }, position: { x: 5, y: -20, z: 0 }, color: 0x2d9bf0, collidable: true, reactive: true }
  ];

  const keys = {};
  const rocketVelocity = new THREE.Vector3();
  const rocketCollider = new THREE.Box3();
  const rocketPreviousPosition = new THREE.Vector3();
  const platforms = [];

  const directionHelper = new THREE.Vector3();
  const rotationAxisZ = new THREE.Vector3(0, 0, 1);
  const targetQuaternion = new THREE.Quaternion();
  const rotationOffset = new THREE.Quaternion();
  const collisionResolutionEpsilon = 0.0015;
  const groundedSnapThreshold = 0.05;

  const joystickInput = new THREE.Vector2();
  let joystickPointerId = null;
  let joystickBaseElement = null;
  let joystickHandleElement = null;

  let isGrounded = false;

  const gravity = 0;
  const thrustAcceleration = 0.04;
  const descendAcceleration = 0.04;
  const maxAscendSpeed = 0.7;
  const maxDescendSpeed = 0.7;
  const verticalDamping = 0.92;
  const groundAcceleration = 0.03;
  const airAcceleration = 0.018;
  const groundFriction = 0.82;
  const airFriction = 0.97;
  const maxGroundSpeed = 0.6;
  const maxAirSpeed = 0.55;

  const pixelRatioLimit = 1.6;
  const cameraOffsetDesktop = new THREE.Vector2(30, 18);
  const cameraOffsetMobile = new THREE.Vector2(26, 28);
  const cameraLookAtDesktop = new THREE.Vector2(8, 4);
  const cameraLookAtMobile = new THREE.Vector2(6, 9);
  const cameraDistanceRanges = {
    desktop: { min: 120, max: 180 },
    mobile: { min: 160, max: 240 }
  };
  const cameraLerpFactor = 0.08;

  document.addEventListener("keydown", event => {
    if (event.code === "KeyJ" && !event.repeat) {
      const currentlyVisible = document.body.classList.contains("show-joystick");
      joystickManualOverride = !currentlyVisible;
      setJoystickVisibility(joystickManualOverride);
      keys[event.code] = false;
      event.preventDefault();
      return;
    }
    keys[event.code] = true;
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space","KeyA","KeyD","KeyW","KeyS"].includes(event.code)) {
      event.preventDefault();
    }
  });

  document.addEventListener("keyup", event => {
    if (event.code === "KeyJ") {
      keys[event.code] = false;
      event.preventDefault();
      return;
    }
    keys[event.code] = false;
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space","KeyA","KeyD","KeyW","KeyS"].includes(event.code)) {
      event.preventDefault();
    }
  });

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x03020f);
    scene.fog = new THREE.Fog(0x03020f, 140, 350);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 600);
    camera.position.set(-5, 12, getTargetCameraZ());

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, pixelRatioLimit));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x03020f, 1);
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const keyLight = new THREE.DirectionalLight(0xfff1c1, 0.9);
    keyLight.position.set(60, 90, 120);
    scene.add(keyLight);

    const rimLight = new THREE.PointLight(0x4dc6ff, 0.6, 250);
    rimLight.position.set(-60, 40, -80);
    scene.add(rimLight);

    createStars();
    initJoystick();
    spawnConfiguredAssets();

    gltfLoader.load(
      "Space_rocket.glb",
      gltf => {
        rocket = new THREE.Group();
        const rocketMesh = gltf.scene;
        rocketMesh.scale.set(3, 3, 3);
        centerModel(rocketMesh);
        rocket.add(rocketMesh);
        rocket.position.set(-40, -10, 0);
        scene.add(rocket);
        rocketCollider.setFromObject(rocket);
        rocket.userData.baseQuaternion = rocket.quaternion.clone();
        rocket.userData.lastQuaternion = rocket.userData.baseQuaternion.clone();

        const thrusterGeometry = new THREE.ConeGeometry(1.4, 4.5, 16, 1, true);
        const thrusterMaterial = new THREE.MeshStandardMaterial({
          color: 0xffa64d,
          emissive: 0xff5b0b,
          emissiveIntensity: 1.2,
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
        thruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
        thruster.rotation.x = Math.PI;
        thruster.position.set(0, -5.4, 0);
        rocket.add(thruster);
        rocket.userData.thrusterMaterial = thrusterMaterial;

        thrusterLight = new THREE.PointLight(0xff9551, 1.1, 55, 2);
        thrusterLight.position.set(0, -4.5, 0);
        rocket.add(thrusterLight);
        initThrusterParticles();
      },
      undefined,
      error => {
        console.error("Failed to load rocket:", error);
      }
    );

    window.addEventListener("resize", onWindowResize, false);
    window.addEventListener("resize", resetJoystick);
    window.addEventListener("blur", resetJoystick);
  }

  function createThrusterParticleTexture() {
    const size = 64;
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const context = canvas.getContext("2d");
    const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
    gradient.addColorStop(0, "rgba(255,255,255,1)");
    gradient.addColorStop(0.35, "rgba(255,214,163,0.95)");
    gradient.addColorStop(0.6, "rgba(255,140,40,0.65)");
    gradient.addColorStop(1, "rgba(255,95,20,0)");
    context.clearRect(0, 0, size, size);
    context.fillStyle = gradient;
    context.fillRect(0, 0, size, size);
    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.wrapS = THREE.ClampToEdgeWrapping;
    texture.wrapT = THREE.ClampToEdgeWrapping;
    return texture;
  }

  function initThrusterParticles() {
    if (!rocket) return;

    if (thrusterParticles) {
      rocket.remove(thrusterParticles);
      if (thrusterParticles.geometry) thrusterParticles.geometry.dispose();
      if (thrusterParticles.material) thrusterParticles.material.dispose();
    }

    thrusterParticleData.length = 0;
    thrusterParticleSpawnAccumulator = 0;

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(thrusterParticleCount * 3);
    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

    if (!thrusterParticleTexture) {
      thrusterParticleTexture = createThrusterParticleTexture();
    }

    const material = new THREE.PointsMaterial({
      map: thrusterParticleTexture,
      size: 1.8,
      transparent: true,
      opacity: 0,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      vertexColors: false,
      sizeAttenuation: true
    });

    thrusterParticles = new THREE.Points(geometry, material);
    thrusterParticles.frustumCulled = false;
    thrusterParticles.visible = false;
    thrusterParticles.position.set(0, -5.8, 0);
    rocket.add(thrusterParticles);

    for (let i = 0; i < thrusterParticleCount; i++) {
      thrusterParticleData.push({
        velocity: new THREE.Vector3(),
        life: 0,
        maxLife: 0
      });
    }
  }

  function respawnThrusterParticle(index, strength) {
    if (!thrusterParticles) return;
    const positions = thrusterParticles.geometry.attributes.position.array;
    const data = thrusterParticleData[index];
    const spread = 1.1 + strength * 0.9;
    const idx = index * 3;
    positions[idx] = (Math.random() - 0.5) * spread;
    positions[idx + 1] = -0.4 - Math.random() * 0.35;
    positions[idx + 2] = (Math.random() - 0.5) * spread;

    const lateralScale = 1.05 + strength * 0.85;
    const baseSpeed = 14 + strength * 20;

    data.velocity.set(
      (Math.random() - 0.5) * lateralScale,
      -(baseSpeed + Math.random() * 6),
      (Math.random() - 0.5) * lateralScale
    );
    data.maxLife = 0.25 + Math.random() * 0.25 + strength * 0.22;
    data.life = data.maxLife;
  }

  function updateThrusterParticles(strength, delta) {
    if (!thrusterParticles || !thrusterParticles.geometry) return;

    const positions = thrusterParticles.geometry.attributes.position.array;

    for (let i = 0; i < thrusterParticleData.length; i++) {
      const data = thrusterParticleData[i];
      if (data.life > 0) {
        const idx = i * 3;
        data.life -= delta;
        positions[idx] += data.velocity.x * delta;
        positions[idx + 1] += data.velocity.y * delta;
        positions[idx + 2] += data.velocity.z * delta;

        data.velocity.x *= 0.94;
        data.velocity.z *= 0.94;
        data.velocity.y -= 14 * delta;

        if (data.life <= 0) {
          positions[idx + 1] = -7 - Math.random() * 3;
        }
      }
    }

    if (strength > 0.05) {
      thrusterParticleSpawnAccumulator += strength * 140 * delta;
      let spawnBudget = Math.floor(thrusterParticleSpawnAccumulator);
      if (spawnBudget > 0) {
        for (let s = 0; s < spawnBudget; s++) {
          const slot = thrusterParticleData.findIndex(entry => entry.life <= 0);
          if (slot === -1) break;
          respawnThrusterParticle(slot, strength);
        }
        thrusterParticleSpawnAccumulator -= spawnBudget;
      }
    } else {
      thrusterParticleSpawnAccumulator = 0;
    }

    const material = thrusterParticles.material;
    const targetOpacity = strength > 0.05 ? 0.4 + strength * 0.55 : 0;
    const targetSize = 1.6 + strength * 2.2;
    material.opacity = THREE.MathUtils.lerp(material.opacity, targetOpacity, 0.25);
    material.size = THREE.MathUtils.lerp(material.size, targetSize, 0.2);
    thrusterParticles.visible = material.opacity > 0.02;
    thrusterParticles.geometry.attributes.position.needsUpdate = true;
  }

  function centerModel(model) {
    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    model.position.sub(center);
  }

  function setMatrixAutoUpdateRecursive(object, enabled) {
    if (!object) return;
    object.matrixAutoUpdate = enabled;
    if (object.children && object.children.length) {
      object.children.forEach(child => setMatrixAutoUpdateRecursive(child, enabled));
    }
  }

  function applyTransformFromConfig(object, config) {
    if (!config || !object) return;
    if (config.position) {
      const position = config.position;
      object.position.set(
        position.x !== undefined ? position.x : object.position.x,
        position.y !== undefined ? position.y : object.position.y,
        position.z !== undefined ? position.z : object.position.z
      );
    }
    if (config.rotationRadians) {
      const rotationRadians = config.rotationRadians;
      object.rotation.set(
        rotationRadians.x !== undefined ? rotationRadians.x : object.rotation.x,
        rotationRadians.y !== undefined ? rotationRadians.y : object.rotation.y,
        rotationRadians.z !== undefined ? rotationRadians.z : object.rotation.z
      );
    } else if (config.rotation) {
      const rotation = config.rotation;
      const rx = rotation.x !== undefined ? THREE.MathUtils.degToRad(rotation.x) : object.rotation.x;
      const ry = rotation.y !== undefined ? THREE.MathUtils.degToRad(rotation.y) : object.rotation.y;
      const rz = rotation.z !== undefined ? THREE.MathUtils.degToRad(rotation.z) : object.rotation.z;
      object.rotation.set(rx, ry, rz);
    }
    if (config.scale !== undefined) {
      if (typeof config.scale === "number") {
        object.scale.setScalar(config.scale);
      } else {
        const scale = config.scale;
        object.scale.set(
          scale.x !== undefined ? scale.x : object.scale.x,
          scale.y !== undefined ? scale.y : object.scale.y,
          scale.z !== undefined ? scale.z : object.scale.z
        );
      }
    }
  }

  function registerStaticColliderIfNeeded(object, config) {
    if (!config || !config.collidable) return;
    const collider = new THREE.Box3().setFromObject(object);
    const entry = {
      object,
      collider,
      config,
      reactive: !!config.reactive,
      velocity: new THREE.Vector3(),
      angularVelocity: new THREE.Vector3(),
      isTouching: false
    };
    platforms.push(entry);
  }

  function applyImpulseToReactivePlatform(platform, impactVelocity, axis, direction) {
    if (!platform || !platform.reactive) return;
    const config = platform.config || {};
    const impulseStrength = config.reactiveImpulse !== undefined ? config.reactiveImpulse : 0.35;
    const spinStrength = config.reactiveSpin !== undefined ? config.reactiveSpin : 0.03;
    const maxLinearSpeed = config.reactiveMaxSpeed !== undefined ? config.reactiveMaxSpeed : 2.2;
    const maxSpin = config.reactiveMaxSpin !== undefined ? config.reactiveMaxSpin : 0.12;

    if (impactVelocity && impactVelocity.lengthSq() > 0) {
      platform.velocity.addScaledVector(impactVelocity, impulseStrength);
    }

    if (platform.velocity.lengthSq() < 0.0001) {
      if (axis === "x") {
        platform.velocity.x += (direction || 0) * impulseStrength * 0.6;
      } else if (axis === "y") {
        platform.velocity.y += (direction || 0) * impulseStrength * 0.6;
      }
    }

    if (axis === "x") {
      platform.angularVelocity.z += (-(impactVelocity ? impactVelocity.y : 0) + (direction || 0) * 0.3) * spinStrength;
    } else if (axis === "y") {
      platform.angularVelocity.z += ((impactVelocity ? impactVelocity.x : 0) - (direction || 0) * 0.3) * spinStrength;
    } else {
      platform.angularVelocity.z += (Math.random() - 0.5) * spinStrength;
    }

    if (maxLinearSpeed > 0) {
      const maxLinearSq = maxLinearSpeed * maxLinearSpeed;
      if (platform.velocity.lengthSq() > maxLinearSq) {
        platform.velocity.setLength(maxLinearSpeed);
      }
    }

    platform.angularVelocity.z = THREE.MathUtils.clamp(platform.angularVelocity.z, -maxSpin, maxSpin);
  }

  function updateReactivePlatforms() {
    for (let i = 0; i < platforms.length; i++) {
      const platform = platforms[i];
      if (!platform.reactive || !platform.object) continue;
      const config = platform.config || {};
      const damping = config.reactiveDamping !== undefined ? THREE.MathUtils.clamp(config.reactiveDamping, 0, 0.999) : 0.9;
      const angularDamping = config.reactiveAngularDamping !== undefined ? THREE.MathUtils.clamp(config.reactiveAngularDamping, 0, 0.999) : 0.92;

      if (platform.velocity.lengthSq() > 0) {
        platform.velocity.multiplyScalar(damping);
        if (platform.velocity.lengthSq() < 0.000001) {
          platform.velocity.set(0, 0, 0);
        } else {
          platform.object.position.add(platform.velocity);
        }
      }

      if (platform.angularVelocity.lengthSq() > 0) {
        platform.angularVelocity.multiplyScalar(angularDamping);
        if (platform.angularVelocity.lengthSq() < 0.000001) {
          platform.angularVelocity.set(0, 0, 0);
        } else {
          platform.object.rotation.x += platform.angularVelocity.x;
          platform.object.rotation.y += platform.angularVelocity.y;
          platform.object.rotation.z += platform.angularVelocity.z;
        }
      }

      if (platform.velocity.lengthSq() > 0 || platform.angularVelocity.lengthSq() > 0) {
        platform.collider.setFromObject(platform.object);
      }
    }
  }
  function inferModelType(config) {
    if (!config) return "";
    if (config.type) return String(config.type).toLowerCase();
    if (!config.url) return "";
    const sanitized = config.url.split('#')[0].split('?')[0];
    const match = sanitized.match(/\.([a-z0-9]+)$/i);
    return match ? match[1].toLowerCase() : "";
  }

  function getLoaderForModelType(type) {
    switch (type) {
      case "gltf":
      case "glb":
        return gltfLoader;
      default:
        return null;
    }
  }

  function applyShadowSettings(target, config) {
    const cast = config.castShadow;
    const receive = config.receiveShadow;
    if (cast === undefined && receive === undefined) return;
    const apply = object => {
      if (object.isMesh || object.isPoints || object.isLine) {
        if (cast !== undefined) object.castShadow = !!cast;
        if (receive !== undefined) object.receiveShadow = !!receive;
      }
    };
    if (target.traverse) {
      target.traverse(apply);
    } else {
      apply(target);
    }
  }

  function createMaterialFromConfig(config, geometry) {
    if (config.material instanceof THREE.Material) {
      return config.material;
    }
    const materialOptions = Object.assign(
      {
        color: config.color !== undefined ? config.color : 0xffffff,
        metalness: config.metalness !== undefined ? config.metalness : 0.2,
        roughness: config.roughness !== undefined ? config.roughness : 0.65,
        flatShading: !!config.flatShading
      },
      config.materialOptions || {}
    );
    if (geometry && geometry.getAttribute && geometry.getAttribute('color')) {
      materialOptions.vertexColors = true;
    }
    if (config.wireframe !== undefined) {
      materialOptions.wireframe = !!config.wireframe;
    }
    return new THREE.MeshStandardMaterial(materialOptions);
  }

  function buildObjectFromResult(type, result, config) {
    switch (type) {
      case "gltf":
      case "glb": {
        const scene = result && (result.scene || (result.scenes && result.scenes[0]));
        if (!scene) return null;
        return { object: scene, raw: result };
      }
      default:
        console.warn(`Tipe model "${type}" belum didukung untuk ${config.url}`);
        return null;
    }
  }

  function finalizeLoadedModel(model, config, rawResult, options = {}) {
    if (!model) return;
    if (config.name) {
      model.name = config.name;
    }
    applyShadowSettings(model, config);
    if (config.center && !options.skipCenter) {
      centerModel(model);
    }
    applyTransformFromConfig(model, config);
    if (config.lookAt) {
      const lookAt = config.lookAt;
      model.lookAt(
        lookAt.x !== undefined ? lookAt.x : 0,
        lookAt.y !== undefined ? lookAt.y : 0,
        lookAt.z !== undefined ? lookAt.z : 0
      );
    }
    setMatrixAutoUpdateRecursive(model, true);
    model.updateMatrixWorld(true);
    scene.add(model);
    if (config.name) {
      namedModels.set(config.name, model);
      resolvePendingOrbitRegistrations(config.name);
    }
    registerLightForModel(model, config);
    registerOrbitAnimationIfNeeded(model, config);
    registerRotationAnimationIfNeeded(model, config);
    registerStaticColliderIfNeeded(model, config);
    if (typeof config.onLoad === "function") {
      config.onLoad(model, rawResult);
    }
  }

  function loadConfiguredModels() {
    modelConfigs.forEach(config => {
      if (!config || !config.url) return;
      const type = inferModelType(config);
      if (!type) {
        console.warn(`Gagal menebak tipe model untuk ${config.url}`);
        return;
      }
      const loader = getLoaderForModelType(type);
      if (!loader || !loader.load) {
        console.warn(`Loader untuk tipe "${type}" belum tersedia.`, config.url);
        return;
      }

      const previousResourcePath = loader.resourcePath !== undefined ? loader.resourcePath : undefined;
      const previousPath = loader.path !== undefined ? loader.path : undefined;

      const resetLoaderPaths = () => {
        if (config.resourcePath && loader.setResourcePath) {
          loader.setResourcePath(previousResourcePath || "");
        }
        if (config.path && loader.setPath) {
          loader.setPath(previousPath || "");
        }
      };

      const handleSuccess = result => {
        resetLoaderPaths();
        const built = buildObjectFromResult(type, result, config);
        if (!built || !built.object) return;
        finalizeLoadedModel(built.object, config, built.raw, { skipCenter: built.skipCenter });
      };

      const handleError = error => {
        resetLoaderPaths();
        console.error(`Gagal load model (${type}):`, config.url, error);
        if (typeof config.onError === "function") {
          config.onError(error);
        }
      };

      if (config.resourcePath && loader.setResourcePath) {
        loader.setResourcePath(config.resourcePath);
      }
      if (config.path && loader.setPath) {
        loader.setPath(config.path);
      }

      loader.load(config.url, handleSuccess, config.onProgress, handleError);
    });
  }
  function loadConfiguredImages() {
    imageConfigs.forEach(config => {
      textureLoader.load(
        config.url,
        texture => {
          const defaultWidth = 14;
          const width = config.width !== undefined ? config.width : defaultWidth;
          let height;
          if (config.height !== undefined) {
            height = config.height;
          } else if (texture.image && texture.image.width) {
            const ratio = texture.image.height / texture.image.width;
            height = width * ratio;
          } else {
            height = defaultWidth;
          }
          const geometry = new THREE.PlaneGeometry(width, height);
          const materialOptions = {
            map: texture,
            transparent: config.transparent !== undefined ? config.transparent : true,
            side: THREE.DoubleSide
          };
          if (config.opacity !== undefined) {
            materialOptions.opacity = config.opacity;
            materialOptions.transparent = true;
          }
          const material = new THREE.MeshBasicMaterial(materialOptions);
          const mesh = new THREE.Mesh(geometry, material);
          applyTransformFromConfig(mesh, config);
          scene.add(mesh);
          registerStaticColliderIfNeeded(mesh, config);
        },
        undefined,
        error => {
          console.error("Failed to load image:", config.url, error);
        }
      );
    });
  }

  function loadFont(url, onLoad, onError) {
    if (fontCache.has(url)) {
      onLoad(fontCache.get(url));
      return;
    }
    fontLoader.load(
      url,
      font => {
        fontCache.set(url, font);
        onLoad(font);
      },
      undefined,
      error => {
        console.error("Failed to load font:", url, error);
        if (onError) onError(error);
      }
    );
  }

  function createTextMeshFromConfig(font, config) {
    const text = config.text || "";
    const size = config.size !== undefined ? config.size : 6;
    const height = config.height !== undefined ? config.height : 1.2;
    const curveSegments = config.curveSegments !== undefined ? config.curveSegments : 8;
    const bevelEnabled = !!config.bevelEnabled;
    const bevelThickness = config.bevelThickness !== undefined ? config.bevelThickness : 0.2;
    const bevelSize = config.bevelSize !== undefined ? config.bevelSize : 0.3;
    const bevelOffset = config.bevelOffset !== undefined ? config.bevelOffset : 0;
    const bevelSegments = config.bevelSegments !== undefined ? config.bevelSegments : 4;

    const geometry = new THREE.TextGeometry(text, {
      font,
      size,
      height,
      curveSegments,
      bevelEnabled,
      bevelThickness,
      bevelSize,
      bevelOffset,
      bevelSegments
    });

    geometry.computeBoundingBox();
    const boundingBox = geometry.boundingBox;
    if (config.center || config.align === "center") {
      const center = boundingBox.getCenter(new THREE.Vector3());
      geometry.translate(-center.x, -center.y, -center.z);
    } else if (config.align === "middle") {
      const centerX = (boundingBox.max.x + boundingBox.min.x) * 0.5;
      geometry.translate(-centerX, 0, 0);
    }

    const materialOptions = {
      color: config.color !== undefined ? config.color : 0xffffff,
      metalness: config.metalness !== undefined ? config.metalness : 0.4,
      roughness: config.roughness !== undefined ? config.roughness : 0.35
    };
    if (config.opacity !== undefined) {
      materialOptions.transparent = true;
      materialOptions.opacity = config.opacity;
    }

    const material = new THREE.MeshStandardMaterial(materialOptions);
    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = config.castShadow !== undefined ? config.castShadow : true;
    mesh.receiveShadow = !!config.receiveShadow;

    return mesh;
  }

  function loadConfiguredTexts() {
    textConfigs.forEach(config => {
      const fontUrl = config.fontUrl || defaultFontUrl;
      loadFont(
        fontUrl,
        font => {
          if (!font) return;
          const mesh = createTextMeshFromConfig(font, config);
          applyTransformFromConfig(mesh, config);
          scene.add(mesh);
          registerStaticColliderIfNeeded(mesh, config);
          if (typeof config.onLoad === "function") {
            config.onLoad(mesh, font);
          }
        }
      );
    });
  }

  function loadConfiguredBoxes() {
    boxConfigs.forEach(config => {
      const size = config.size || {};
      const width = size.x !== undefined ? size.x : (size.width !== undefined ? size.width : 12);
      const height = size.y !== undefined ? size.y : (size.height !== undefined ? size.height : 12);
      const depth = size.z !== undefined ? size.z : (size.depth !== undefined ? size.depth : 12);
      const geometry = new THREE.BoxGeometry(width, height, depth);
      const materialOptions = {
        color: config.color !== undefined ? config.color : 0x4dc6ff,
        metalness: config.metalness !== undefined ? config.metalness : 0.2,
        roughness: config.roughness !== undefined ? config.roughness : 0.7
      };
      if (config.opacity !== undefined) {
        materialOptions.transparent = true;
        materialOptions.opacity = config.opacity;
      }
      const material = new THREE.MeshStandardMaterial(materialOptions);
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = !!config.castShadow;
      mesh.receiveShadow = !!config.receiveShadow;
      applyTransformFromConfig(mesh, config);
      scene.add(mesh);
      registerStaticColliderIfNeeded(mesh, config);
    });
  }

  function spawnConfiguredAssets() {
    loadConfiguredModels();
    loadConfiguredImages();
    loadConfiguredTexts();
    loadConfiguredBoxes();
  }

  function createStars() {
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 2500;
    const starPositions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      starPositions[i * 3] = (Math.random() - 0.5) * 800;
      starPositions[i * 3 + 1] = (Math.random() - 0.5) * 600;
      starPositions[i * 3 + 2] = (Math.random() - 0.5) * 600;
    }
    starGeometry.setAttribute("position", new THREE.BufferAttribute(starPositions, 3));
    const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, sizeAttenuation: true, opacity: 0.85, transparent: true });
    stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);
  }

  function initJoystick() {
    joystickBaseElement = document.querySelector(".joystick-base");
    joystickHandleElement = document.querySelector(".joystick-handle");
    const joystickZone = document.querySelector(".joystick");
    if (!joystickBaseElement || !joystickHandleElement || !joystickZone) return;

    const handlePointerDown = event => {
      if (joystickPointerId !== null) return;
      joystickPointerId = event.pointerId;
      joystickHandleElement.style.transition = "none";
      if (joystickZone.setPointerCapture) {
        try {
          joystickZone.setPointerCapture(joystickPointerId);
        } catch (error) {}
      }
      event.preventDefault();
      updateJoystickFromPointer(event);
    };

    const handlePointerMove = event => {
      if (event.pointerId !== joystickPointerId) return;
      event.preventDefault();
      updateJoystickFromPointer(event);
    };

    const handlePointerUp = event => {
      if (event.pointerId !== joystickPointerId) return;
      if (joystickZone.releasePointerCapture) {
        try {
          joystickZone.releasePointerCapture(joystickPointerId);
        } catch (error) {}
      }
      event.preventDefault();
      resetJoystick();
    };

    joystickZone.addEventListener("pointerdown", handlePointerDown);
    joystickZone.addEventListener("pointermove", handlePointerMove);
    joystickZone.addEventListener("pointerup", handlePointerUp);
    joystickZone.addEventListener("pointercancel", handlePointerUp);
    joystickZone.addEventListener("lostpointercapture", resetJoystick);

    resetJoystick();
  }

  function updateJoystickFromPointer(event) {
    if (!joystickBaseElement || !joystickHandleElement) return;
    const rect = joystickBaseElement.getBoundingClientRect();
    const centerX = rect.left + rect.width * 0.5;
    const centerY = rect.top + rect.height * 0.5;
    let dx = event.clientX - centerX;
    let dy = event.clientY - centerY;
    const radius = rect.width * 0.5;
    const distance = Math.hypot(dx, dy);
    if (distance > radius) {
      const ratio = radius / distance;
      dx *= ratio;
      dy *= ratio;
    }
    joystickInput.set(dx / radius, -(dy / radius));
    joystickHandleElement.style.transition = "none";
    updateJoystickVisual(dx, dy);
  }

  function updateJoystickVisual(offsetX, offsetY) {
    if (!joystickHandleElement) return;
    joystickHandleElement.style.setProperty("--offset-x", `${offsetX}px`);
    joystickHandleElement.style.setProperty("--offset-y", `${offsetY}px`);
  }

  function resetJoystick() {
    joystickPointerId = null;
    joystickInput.set(0, 0);
    if (!joystickHandleElement) return;
    joystickHandleElement.style.transition = "transform 0.12s ease";
    updateJoystickVisual(0, 0);
  }

  function shouldUseMobileCamera() {
    if (joystickAutoVisible) return true;
    if (joystickTouchActivated) return true;
    return false;
  }

  function getActiveCameraRange() {
    return shouldUseMobileCamera() ? cameraDistanceRanges.mobile : cameraDistanceRanges.desktop;
  }

  function getTargetCameraZ() {
    const aspect = window.innerWidth / window.innerHeight;
    const normalized = THREE.MathUtils.clamp((aspect - 0.85) / 1.4, 0, 1);
    const range = getActiveCameraRange();
    return THREE.MathUtils.lerp(range.min, range.max, normalized);
  }

  function updateRocket() {
    if (!rocket) return;

    const now = performance.now();
    if (lastRocketUpdateTime === null) {
      lastRocketUpdateTime = now;
    }
    const delta = Math.min((now - lastRocketUpdateTime) / 1000, 0.05);
    lastRocketUpdateTime = now;

    updateReactivePlatforms();

    rocketPreviousPosition.copy(rocket.position);

    const leftPressed = keys["ArrowLeft"] || keys["KeyA"];
    const rightPressed = keys["ArrowRight"] || keys["KeyD"];
    const thrustPressed = keys["Space"] || keys["ArrowUp"] || keys["KeyW"];
    const descendPressed = keys["ArrowDown"] || keys["KeyS"];

    const acceleration = isGrounded ? groundAcceleration : airAcceleration;
    const maxSpeed = isGrounded ? maxGroundSpeed : maxAirSpeed;

    let horizontalInput = 0;
    if (Math.abs(joystickInput.x) > 0.05) {
      horizontalInput = THREE.MathUtils.clamp(joystickInput.x, -1, 1);
    } else if (leftPressed) {
      horizontalInput = -1;
    } else if (rightPressed) {
      horizontalInput = 1;
    }

    if (horizontalInput !== 0) {
      rocketVelocity.x = THREE.MathUtils.clamp(rocketVelocity.x + horizontalInput * acceleration, -maxSpeed, maxSpeed);
    } else {
      rocketVelocity.x *= isGrounded ? groundFriction : airFriction;
      if (Math.abs(rocketVelocity.x) < 0.01) {
        rocketVelocity.x = 0;
      }
    }

    let verticalInput = 0;
    if (Math.abs(joystickInput.y) > 0.05) {
      verticalInput = THREE.MathUtils.clamp(joystickInput.y, -1, 1);
    } else if (thrustPressed) {
      verticalInput = 1;
    } else if (descendPressed) {
      verticalInput = -1;
    }

    if (verticalInput > 0) {
      rocketVelocity.y = THREE.MathUtils.clamp(rocketVelocity.y + thrustAcceleration * verticalInput, -maxDescendSpeed, maxAscendSpeed);
    } else if (verticalInput < 0) {
      rocketVelocity.y = THREE.MathUtils.clamp(rocketVelocity.y + descendAcceleration * verticalInput, -maxDescendSpeed, maxAscendSpeed);
    } else {
      rocketVelocity.y *= verticalDamping;
      if (Math.abs(rocketVelocity.y) < 0.01) {
        rocketVelocity.y = 0;
      }
    }

    let flameStrength = 0;
    if (thruster && rocket.userData.thrusterMaterial && thrusterLight) {
      const velocityStrength = THREE.MathUtils.clamp(rocketVelocity.length() / maxAscendSpeed, 0, 1);
      const inputStrength = Math.max(0, verticalInput);
      const horizontalStrength = Math.abs(horizontalInput) * 0.6;
      flameStrength = THREE.MathUtils.clamp(Math.max(inputStrength, velocityStrength * 0.75, horizontalStrength), 0, 1);
      const time = performance.now() * 0.002;
      const flicker = Math.sin(time * 7.5) * 0.1 + Math.sin(time * 13.0) * 0.05;
      const scaleY = 1.1 + flameStrength * 1.6 + flicker;
      const scaleX = 0.85 + flameStrength * 0.6;
      thruster.scale.set(scaleX, scaleY, scaleX);
      thruster.position.y = -5.6 - flameStrength * 1.6;
      const material = rocket.userData.thrusterMaterial;
      material.opacity = 0.35 + flameStrength * 0.5;
      material.emissiveIntensity = 0.8 + flameStrength * 1.8;
      thruster.visible = flameStrength > 0.05;
      thrusterLight.intensity = 0.7 + flameStrength * 2.8;
      thrusterLight.distance = 40 + flameStrength * 34;
      thrusterLight.position.y = -4.8 - flameStrength * 1.3;
    }

    updateThrusterParticles(flameStrength, delta);

    rocket.position.add(rocketVelocity);
    rocketCollider.setFromObject(rocket);
    isGrounded = false;

    resolveCollisions();

    directionHelper.set(rocketVelocity.x, rocketVelocity.y, 0);
    if (directionHelper.lengthSq() < 0.0004 && joystickInput.lengthSq() > 0.0025) {
      directionHelper.set(joystickInput.x, joystickInput.y, 0);
    }

    if (rocket.userData.baseQuaternion) {
      if (directionHelper.lengthSq() > 0.000001) {
        directionHelper.normalize();
        const rotationAngle = Math.atan2(-directionHelper.x, directionHelper.y);
        rotationOffset.setFromAxisAngle(rotationAxisZ, rotationAngle);
        targetQuaternion.copy(rocket.userData.baseQuaternion).multiply(rotationOffset);
        if (rocket.userData.lastQuaternion) {
          rocket.userData.lastQuaternion.copy(targetQuaternion);
        }
        rocket.quaternion.slerp(targetQuaternion, 0.2);
      } else if (rocket.userData.lastQuaternion) {
        rocket.quaternion.slerp(rocket.userData.lastQuaternion, 0.12);
      }
    }

    rocket.position.z = 0;

  }

  function resolveCollisions() {
    if (!rocket) return;

    const movementX = rocket.position.x - rocketPreviousPosition.x;
    const movementY = rocket.position.y - rocketPreviousPosition.y;
    const axisOrder = [
      { axis: "x", delta: movementX },
      { axis: "y", delta: movementY }
    ];

    for (let i = 0; i < platforms.length; i++) {
      platforms[i]._touchThisFrame = false;
    }

    for (let a = 0; a < axisOrder.length; a++) {
      const { axis, delta } = axisOrder[a];
      rocketCollider.setFromObject(rocket);

      for (let i = 0; i < platforms.length; i++) {
        const platform = platforms[i];
        const collider = platform.collider;
        if (!collider) continue;

        if (!rocketCollider.intersectsBox(collider)) continue;

        const overlapPositive = rocketCollider.max[axis] - collider.min[axis];
        const overlapNegative = collider.max[axis] - rocketCollider.min[axis];

        if (overlapPositive <= 0 || overlapNegative <= 0) continue;

        const wasTouching = platform.isTouching === true;
        let shift = 0;
        let direction = 0;

        if (delta > 0) {
          shift = -(overlapPositive + collisionResolutionEpsilon);
          direction = 1;
        } else if (delta < 0) {
          shift = overlapNegative + collisionResolutionEpsilon;
          direction = -1;
        } else {
          const rocketCenter = (rocketCollider.min[axis] + rocketCollider.max[axis]) * 0.5;
          const platformCenter = (collider.min[axis] + collider.max[axis]) * 0.5;
          if (rocketCenter >= platformCenter) {
            shift = overlapNegative + collisionResolutionEpsilon;
            direction = -1;
          } else {
            shift = -(overlapPositive + collisionResolutionEpsilon);
            direction = 1;
          }
        }

        if (shift === 0) continue;

        const impactVelocity = rocketVelocity.clone();
        rocket.position[axis] += shift;
        rocketCollider.setFromObject(rocket);

        if (axis === "x") {
          rocketVelocity.x = 0;
        } else if (axis === "y") {
          rocketVelocity.y = 0;
          if (shift > 0) {
            isGrounded = true;
          }
        }

        platform._touchThisFrame = true;

        if (!wasTouching && platform.reactive) {
          applyImpulseToReactivePlatform(platform, impactVelocity, axis, direction);
        }
      }
    }

    if (!isGrounded) {
      rocketCollider.setFromObject(rocket);
      let groundedPlatform = null;

      for (let i = 0; i < platforms.length; i++) {
        const platform = platforms[i];
        const collider = platform.collider;
        if (!collider) continue;

        const horizontalOverlap =
          rocketCollider.max.x > collider.min.x &&
          rocketCollider.min.x < collider.max.x &&
          rocketCollider.max.z > collider.min.z &&
          rocketCollider.min.z < collider.max.z;

        if (!horizontalOverlap) continue;

        const verticalGap = rocketCollider.min.y - collider.max.y;
        if (verticalGap >= 0 && verticalGap <= groundedSnapThreshold) {
          groundedPlatform = platform;
          isGrounded = true;
          break;
        }
      }

      if (groundedPlatform) {
        groundedPlatform._touchThisFrame = true;
      }
    }

    for (let i = 0; i < platforms.length; i++) {
      const platform = platforms[i];
      platform.isTouching = platform._touchThisFrame === true;
      delete platform._touchThisFrame;
    }
  }
  function updateCamera() {
    if (!rocket) return;

    const mobileCamera = shouldUseMobileCamera();
    const offset = mobileCamera ? cameraOffsetMobile : cameraOffsetDesktop;
    const lookAtOffset = mobileCamera ? cameraLookAtMobile : cameraLookAtDesktop;
    const targetX = rocket.position.x + offset.x;
    const targetY = rocket.position.y + offset.y;
    camera.position.x += (targetX - camera.position.x) * cameraLerpFactor;
    camera.position.y += (targetY - camera.position.y) * cameraLerpFactor;
    const desiredZ = getTargetCameraZ();
    camera.position.z += (desiredZ - camera.position.z) * cameraLerpFactor;

    camera.lookAt(
      rocket.position.x + lookAtOffset.x,
      rocket.position.y + lookAtOffset.y,
      rocket.position.z
    );

    if (stars) {
      stars.position.x = camera.position.x * 0.1;
      stars.position.y = camera.position.y * 0.05;
    }
  }

  function registerLightForModel(model, config) {
    const lightConfig = config && config.light;
    if (!lightConfig) return;
    const type = lightConfig.type ? String(lightConfig.type).toLowerCase() : "point";
    const color = lightConfig.color !== undefined ? lightConfig.color : 0xffffff;
    const intensity = lightConfig.intensity !== undefined ? lightConfig.intensity : 1.2;
    let light = null;

    switch (type) {
      case "point": {
        const distance = lightConfig.distance !== undefined ? lightConfig.distance : 220;
        const decay = lightConfig.decay !== undefined ? lightConfig.decay : 2;
        light = new THREE.PointLight(color, intensity, distance, decay);
        break;
      }
      case "spot": {
        const distance = lightConfig.distance !== undefined ? lightConfig.distance : 260;
        const angle = lightConfig.angle !== undefined ? THREE.MathUtils.degToRad(lightConfig.angle) : Math.PI / 4;
        const penumbra = lightConfig.penumbra !== undefined ? THREE.MathUtils.clamp(lightConfig.penumbra, 0, 1) : 0.3;
        const decay = lightConfig.decay !== undefined ? lightConfig.decay : 2;
        light = new THREE.SpotLight(color, intensity, distance, angle, penumbra, decay);
        break;
      }
      case "directional": {
        light = new THREE.DirectionalLight(color, intensity);
        break;
      }
      default: {
        console.warn(`Jenis light "${lightConfig.type}" belum didukung, fallback ke PointLight`, config && config.url);
        light = new THREE.PointLight(color, intensity);
      }
    }

    if (!light) return;

    if (lightConfig.castShadow !== undefined) {
      light.castShadow = !!lightConfig.castShadow;
    }
    const offset = lightConfig.offset || {};
    light.position.set(
      offset.x !== undefined ? offset.x : 0,
      offset.y !== undefined ? offset.y : 0,
      offset.z !== undefined ? offset.z : 0
    );

    if (light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight) {
      const targetOffset = lightConfig.targetOffset || { x: 0, y: 0, z: 0 };
      if (!light.target) {
        light.target = new THREE.Object3D();
      }
      light.target.position.set(
        targetOffset.x !== undefined ? targetOffset.x : 0,
        targetOffset.y !== undefined ? targetOffset.y : 0,
        targetOffset.z !== undefined ? targetOffset.z : 0
      );
      model.add(light.target);
    }

    model.add(light);
  }

  function registerOrbitAnimationIfNeeded(model, config) {
    if (!model || !config) return;
    const orbit = config.orbit;
    if (!orbit) return;
    if (model.userData.orbitAnimation) return;
    const enabled = orbit.enabled !== undefined ? !!orbit.enabled : true;
    if (!enabled) return;

    const targetName = orbit.targetName;
    const target = targetName ? namedModels.get(targetName) : null;

    if (targetName && !target) {
      if (model.userData.pendingOrbit === orbit) return;
      model.userData.pendingOrbit = orbit;
      pendingOrbitRegistrations.push({ model, orbit });
      return;
    }

    createOrbitEntry(model, orbit, target);
  }

  function createOrbitEntry(model, orbit, target) {
    const axisConfig = orbit.axis || {};
    const axis = new THREE.Vector3(
      axisConfig.x !== undefined ? axisConfig.x : 0,
      axisConfig.y !== undefined ? axisConfig.y : 1,
      axisConfig.z !== undefined ? axisConfig.z : 0
    );
    if (axis.lengthSq() === 0) {
      axis.set(0, 1, 0);
    } else {
      axis.normalize();
    }

    const radius = orbit.radius !== undefined ? orbit.radius : null;
    const height = orbit.height !== undefined ? orbit.height : 0;
    const depth = orbit.depth !== undefined ? orbit.depth : 0;

    const baseOffset = new THREE.Vector3();
    if (orbit.offset) {
      baseOffset.set(
        orbit.offset.x !== undefined ? orbit.offset.x : 0,
        orbit.offset.y !== undefined ? orbit.offset.y : 0,
        orbit.offset.z !== undefined ? orbit.offset.z : 0
      );
    } else if (radius !== null || height !== 0 || depth !== 0) {
      const resolvedRadius = radius !== null ? radius : 200;
      baseOffset.set(resolvedRadius, height, depth);
    } else if (target) {
      const centerPos = target.getWorldPosition(new THREE.Vector3());
      const modelPos = model.getWorldPosition(new THREE.Vector3());
      baseOffset.copy(modelPos.sub(centerPos));
    } else {
      baseOffset.set(orbit.radius !== undefined ? orbit.radius : 200, height, depth);
    }

    if (baseOffset.lengthSq() === 0) {
      baseOffset.set(orbit.radius !== undefined ? orbit.radius : 200, height !== undefined ? height : 0, depth);
    }

    const angleOffset = THREE.MathUtils.degToRad(orbit.startAngle !== undefined ? orbit.startAngle : 0);
    const speedDeg = orbit.speed !== undefined ? orbit.speed : 15;
    const speedRadPerSec =
      THREE.MathUtils.degToRad(speedDeg) * (orbit.direction === "cw" || orbit.clockwise === true ? -1 : 1);

    const centerOffset = orbit.centerOffset
      ? new THREE.Vector3(
          orbit.centerOffset.x !== undefined ? orbit.centerOffset.x : 0,
          orbit.centerOffset.y !== undefined ? orbit.centerOffset.y : 0,
          orbit.centerOffset.z !== undefined ? orbit.centerOffset.z : 0
        )
      : null;

    const staticCenter = !target && orbit.center
      ? new THREE.Vector3(
          orbit.center.x !== undefined ? orbit.center.x : 0,
          orbit.center.y !== undefined ? orbit.center.y : 0,
          orbit.center.z !== undefined ? orbit.center.z : 0
        )
      : null;

    const entry = {
      model,
      target: target || null,
      staticCenter,
      centerOffset,
      axis,
      baseOffset,
      angle: angleOffset,
      speedRadPerSec,
      faceTarget: !!orbit.faceTarget
    };

    orbitingModels.push(entry);
    model.userData.orbitAnimation = entry;
    delete model.userData.pendingOrbit;

    updateSingleOrbitEntry(entry, 0, false);
  }

  function resolvePendingOrbitRegistrations(resolvedName) {
    if (!pendingOrbitRegistrations.length) return;
    for (let i = pendingOrbitRegistrations.length - 1; i >= 0; i--) {
      const pending = pendingOrbitRegistrations[i];
      const orbit = pending.orbit;
      if (!orbit) {
        pendingOrbitRegistrations.splice(i, 1);
        continue;
      }
      const targetName = orbit.targetName;
      if (targetName && targetName !== resolvedName) continue;
      const target = targetName ? namedModels.get(targetName) : null;
      if (targetName && !target) continue;
      pendingOrbitRegistrations.splice(i, 1);
      createOrbitEntry(pending.model, orbit, target);
    }
  }

  function updateSingleOrbitEntry(entry, deltaSeconds, advanceAngle) {
    if (!entry || !entry.model) return;
    if (advanceAngle && entry.speedRadPerSec !== 0) {
      entry.angle = (entry.angle + entry.speedRadPerSec * deltaSeconds) % (Math.PI * 2);
    }
    orbitTempQuaternion.setFromAxisAngle(entry.axis, entry.angle);
    orbitTempVector.copy(entry.baseOffset).applyQuaternion(orbitTempQuaternion);
    let center;
    if (entry.target) {
      center = entry.target.getWorldPosition(orbitTempCenter);
    } else if (entry.staticCenter) {
      center = orbitTempCenter.copy(entry.staticCenter);
    } else {
      center = orbitTempCenter.set(0, 0, 0);
    }
    if (entry.centerOffset) {
      center.add(entry.centerOffset);
    }
    const newPosition = orbitTempVector.add(center);
    entry.model.position.copy(newPosition);
    if (entry.faceTarget && entry.target) {
      entry.model.lookAt(center);
    }
  }

  function registerRotationAnimationIfNeeded(object, config) {
    const rotate = config && config.rotate;
    if (!rotate) return;
    const enabled = rotate.enabled !== undefined ? !!rotate.enabled : true;
    if (!enabled) return;
    const axisConfig = rotate.axis || {};
    const axis = new THREE.Vector3(
      axisConfig.x !== undefined ? axisConfig.x : 0,
      axisConfig.y !== undefined ? axisConfig.y : 1,
      axisConfig.z !== undefined ? axisConfig.z : 0
    );
    if (axis.lengthSq() === 0) {
      axis.set(0, 1, 0);
    } else {
      axis.normalize();
    }
    const speed = rotate.speed !== undefined ? rotate.speed : 20;
    const entry = {
      object,
      axis,
      speedRadPerSec: THREE.MathUtils.degToRad(speed)
    };
    object.userData.rotationAnimation = entry;
    animatedModels.push(entry);
  }

  function updateAnimatedModels(delta) {
    if (!animatedModels.length) return;
    for (let i = 0; i < animatedModels.length; i++) {
      const entry = animatedModels[i];
      if (!entry || !entry.object) continue;
      const angle = entry.speedRadPerSec * delta;
      if (angle === 0) continue;
      entry.object.rotateOnAxis(entry.axis, angle);
    }
  }

  function updateOrbitingModels(delta) {
    if (!orbitingModels.length) return;
    for (let i = 0; i < orbitingModels.length; i++) {
      updateSingleOrbitEntry(orbitingModels[i], delta, true);
    }
  }

  function animate() {
    requestAnimationFrame(animate);
    const now = performance.now();
    const deltaSeconds = Math.min((now - lastFrameTime) / 1000, 0.05);
    lastFrameTime = now;
    updateOrbitingModels(deltaSeconds);
    updateAnimatedModels(deltaSeconds);
    updateRocket();
    updateCamera();
    renderer.render(scene, camera);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, pixelRatioLimit));
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.position.z = getTargetCameraZ();
  }

  init();
  animate();
</script>
</body>
</html>


























































