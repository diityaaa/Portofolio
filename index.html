<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Roket Platformer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: black; font-family: 'Segoe UI', sans-serif; color: #fff; }
    canvas { display: block; }
    .hud {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 14px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      font-size: 14px;
      letter-spacing: 0.5px;
      pointer-events: none;
    }

    .joystick {
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 140px;
      height: 140px;
      touch-action: none;
      user-select: none;
      z-index: 5;
    }
    .joystick-base {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      backdrop-filter: blur(4px);
      position: relative;
    }
    .joystick-handle {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(77,198,255,0.45);
      border: 2px solid rgba(77,198,255,0.9);
      box-shadow: 0 0 14px rgba(77,198,255,0.6);
      transform: translate(calc(-50% + var(--offset-x, 0px)), calc(-50% + var(--offset-y, 0px)));
      transition: transform 0.12s ease;
    }

    @media (hover: hover) and (pointer: fine) {
      .joystick {
        display: none;
      }
    }
  </style>
</head>
<body>
<div class="hud">gerakin joysticknya bray</div>
<div class="joystick">
  <div class="joystick-base">
    <div class="joystick-handle"></div>
  </div>
</div>
<script>
  let scene, camera, renderer, rocket, stars;
  const gltfLoader = new THREE.GLTFLoader();
  const keys = {};
  const rocketVelocity = new THREE.Vector3();
  const rocketCollider = new THREE.Box3();
  const rocketPreviousPosition = new THREE.Vector3();
  const platforms = [];

  const directionHelper = new THREE.Vector3();
  const rotationAxisZ = new THREE.Vector3(0, 0, 1);
  const targetQuaternion = new THREE.Quaternion();
  const rotationOffset = new THREE.Quaternion();

  const joystickInput = new THREE.Vector2();
  let joystickPointerId = null;
  let joystickBaseElement = null;
  let joystickHandleElement = null;

  let isGrounded = false;

  const gravity = 0;
  const thrustAcceleration = 0.04;
  const descendAcceleration = 0.04;
  const maxAscendSpeed = 0.7;
  const maxDescendSpeed = 0.7;
  const verticalDamping = 0.92;
  const groundAcceleration = 0.03;
  const airAcceleration = 0.018;
  const groundFriction = 0.82;
  const airFriction = 0.97;
  const maxGroundSpeed = 0.6;
  const maxAirSpeed = 0.55;

  const pixelRatioLimit = 1.6;
  const cameraOffset = new THREE.Vector2(30, 18);
  const cameraLookAtOffset = new THREE.Vector2(8, 4);
  const cameraDistanceRange = { min: 120, max: 180 };
  const cameraLerpFactor = 0.08;

  document.addEventListener("keydown", event => {
    keys[event.code] = true;
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space","KeyA","KeyD","KeyW","KeyS"].includes(event.code)) {
      event.preventDefault();
    }
  });

  document.addEventListener("keyup", event => {
    keys[event.code] = false;
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space","KeyA","KeyD","KeyW","KeyS"].includes(event.code)) {
      event.preventDefault();
    }
  });

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x03020f);
    scene.fog = new THREE.Fog(0x03020f, 140, 350);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 600);
    camera.position.set(-5, 12, getTargetCameraZ());

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, pixelRatioLimit));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x03020f, 1);
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const keyLight = new THREE.DirectionalLight(0xfff1c1, 0.9);
    keyLight.position.set(60, 90, 120);
    scene.add(keyLight);

    const rimLight = new THREE.PointLight(0x4dc6ff, 0.6, 250);
    rimLight.position.set(-60, 40, -80);
    scene.add(rimLight);

    createStars();
    initJoystick();

    gltfLoader.load(
      "Space_rocket.glb",
      gltf => {
        rocket = new THREE.Group();
        const rocketMesh = gltf.scene;
        rocketMesh.scale.set(3, 3, 3);
        centerModel(rocketMesh);
        rocket.add(rocketMesh);
        rocket.position.set(-40, -10, 0);
        scene.add(rocket);
        rocketCollider.setFromObject(rocket);
        rocket.userData.baseQuaternion = rocket.quaternion.clone();
      },
      undefined,
      error => {
        console.error("Failed to load rocket:", error);
      }
    );

    window.addEventListener("resize", onWindowResize, false);
    window.addEventListener("resize", resetJoystick);
    window.addEventListener("blur", resetJoystick);
  }

  function centerModel(model) {
    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    model.position.sub(center);
  }

  function createStars() {
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 2500;
    const starPositions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      starPositions[i * 3] = (Math.random() - 0.5) * 800;
      starPositions[i * 3 + 1] = (Math.random() - 0.5) * 600;
      starPositions[i * 3 + 2] = (Math.random() - 0.5) * 600;
    }
    starGeometry.setAttribute("position", new THREE.BufferAttribute(starPositions, 3));
    const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, sizeAttenuation: true, opacity: 0.85, transparent: true });
    stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);
  }

  function initJoystick() {
    joystickBaseElement = document.querySelector(".joystick-base");
    joystickHandleElement = document.querySelector(".joystick-handle");
    const joystickZone = document.querySelector(".joystick");
    if (!joystickBaseElement || !joystickHandleElement || !joystickZone) return;

    const handlePointerDown = event => {
      if (joystickPointerId !== null) return;
      joystickPointerId = event.pointerId;
      joystickHandleElement.style.transition = "none";
      if (joystickZone.setPointerCapture) {
        try {
          joystickZone.setPointerCapture(joystickPointerId);
        } catch (error) {}
      }
      event.preventDefault();
      updateJoystickFromPointer(event);
    };

    const handlePointerMove = event => {
      if (event.pointerId !== joystickPointerId) return;
      event.preventDefault();
      updateJoystickFromPointer(event);
    };

    const handlePointerUp = event => {
      if (event.pointerId !== joystickPointerId) return;
      if (joystickZone.releasePointerCapture) {
        try {
          joystickZone.releasePointerCapture(joystickPointerId);
        } catch (error) {}
      }
      event.preventDefault();
      resetJoystick();
    };

    joystickZone.addEventListener("pointerdown", handlePointerDown);
    joystickZone.addEventListener("pointermove", handlePointerMove);
    joystickZone.addEventListener("pointerup", handlePointerUp);
    joystickZone.addEventListener("pointercancel", handlePointerUp);
    joystickZone.addEventListener("lostpointercapture", resetJoystick);

    resetJoystick();
  }

  function updateJoystickFromPointer(event) {
    if (!joystickBaseElement || !joystickHandleElement) return;
    const rect = joystickBaseElement.getBoundingClientRect();
    const centerX = rect.left + rect.width * 0.5;
    const centerY = rect.top + rect.height * 0.5;
    let dx = event.clientX - centerX;
    let dy = event.clientY - centerY;
    const radius = rect.width * 0.5;
    const distance = Math.hypot(dx, dy);
    if (distance > radius) {
      const ratio = radius / distance;
      dx *= ratio;
      dy *= ratio;
    }
    joystickInput.set(dx / radius, -(dy / radius));
    joystickHandleElement.style.transition = "none";
    updateJoystickVisual(dx, dy);
  }

  function updateJoystickVisual(offsetX, offsetY) {
    if (!joystickHandleElement) return;
    joystickHandleElement.style.setProperty("--offset-x", `${offsetX}px`);
    joystickHandleElement.style.setProperty("--offset-y", `${offsetY}px`);
  }

  function resetJoystick() {
    joystickPointerId = null;
    joystickInput.set(0, 0);
    if (!joystickHandleElement) return;
    joystickHandleElement.style.transition = "transform 0.12s ease";
    updateJoystickVisual(0, 0);
  }

  function getTargetCameraZ() {
    const aspect = window.innerWidth / window.innerHeight;
    const normalized = THREE.MathUtils.clamp((aspect - 0.85) / 1.4, 0, 1);
    return THREE.MathUtils.lerp(cameraDistanceRange.min, cameraDistanceRange.max, normalized);
  }

  function updateRocket() {
    if (!rocket) return;

    rocketPreviousPosition.copy(rocket.position);

    const leftPressed = keys["ArrowLeft"] || keys["KeyA"];
    const rightPressed = keys["ArrowRight"] || keys["KeyD"];
    const thrustPressed = keys["Space"] || keys["ArrowUp"] || keys["KeyW"];
    const descendPressed = keys["ArrowDown"] || keys["KeyS"];

    const acceleration = isGrounded ? groundAcceleration : airAcceleration;
    const maxSpeed = isGrounded ? maxGroundSpeed : maxAirSpeed;

    let horizontalInput = 0;
    if (Math.abs(joystickInput.x) > 0.05) {
      horizontalInput = THREE.MathUtils.clamp(joystickInput.x, -1, 1);
    } else if (leftPressed) {
      horizontalInput = -1;
    } else if (rightPressed) {
      horizontalInput = 1;
    }

    if (horizontalInput !== 0) {
      rocketVelocity.x = THREE.MathUtils.clamp(rocketVelocity.x + horizontalInput * acceleration, -maxSpeed, maxSpeed);
    } else {
      rocketVelocity.x *= isGrounded ? groundFriction : airFriction;
      if (Math.abs(rocketVelocity.x) < 0.01) {
        rocketVelocity.x = 0;
      }
    }

    let verticalInput = 0;
    if (Math.abs(joystickInput.y) > 0.05) {
      verticalInput = THREE.MathUtils.clamp(joystickInput.y, -1, 1);
    } else if (thrustPressed) {
      verticalInput = 1;
    } else if (descendPressed) {
      verticalInput = -1;
    }

    if (verticalInput > 0) {
      rocketVelocity.y = THREE.MathUtils.clamp(rocketVelocity.y + thrustAcceleration * verticalInput, -maxDescendSpeed, maxAscendSpeed);
    } else if (verticalInput < 0) {
      rocketVelocity.y = THREE.MathUtils.clamp(rocketVelocity.y + descendAcceleration * verticalInput, -maxDescendSpeed, maxAscendSpeed);
    } else {
      rocketVelocity.y *= verticalDamping;
      if (Math.abs(rocketVelocity.y) < 0.01) {
        rocketVelocity.y = 0;
      }
    }

    rocket.position.add(rocketVelocity);
    rocketCollider.setFromObject(rocket);
    isGrounded = false;

    resolveCollisions();

    directionHelper.set(rocketVelocity.x, rocketVelocity.y, 0);
    if (directionHelper.lengthSq() < 0.0004 && joystickInput.lengthSq() > 0.0025) {
      directionHelper.set(joystickInput.x, joystickInput.y, 0);
    }

    if (directionHelper.lengthSq() > 0.000001 && rocket.userData.baseQuaternion) {
      directionHelper.normalize();
      const rotationAngle = Math.atan2(-directionHelper.x, directionHelper.y);
      rotationOffset.setFromAxisAngle(rotationAxisZ, rotationAngle);
      targetQuaternion.copy(rocket.userData.baseQuaternion).multiply(rotationOffset);
      rocket.quaternion.slerp(targetQuaternion, 0.2);
    } else if (rocket.userData.baseQuaternion) {
      rocket.quaternion.slerp(rocket.userData.baseQuaternion, 0.12);
    }

    rocket.position.z = 0;

    if (rocket.position.y < -120) {
      rocket.position.set(-40, 10, 0);
      rocketVelocity.set(0, 0, 0);
      rocketCollider.setFromObject(rocket);
    }
  }

  function resolveCollisions() {
    if (!rocket) return;

    for (let i = 0; i < platforms.length; i++) {
      const platform = platforms[i];
      const collider = platform.collider;

      if (!rocketCollider.intersectsBox(collider)) continue;

      const deltaX = rocket.position.x - rocketPreviousPosition.x;
      const deltaY = rocket.position.y - rocketPreviousPosition.y;

      const overlapRight = rocketCollider.max.x - collider.min.x;
      const overlapLeft = collider.max.x - rocketCollider.min.x;
      const overlapUp = collider.max.y - rocketCollider.min.y;
      const overlapDown = rocketCollider.max.y - collider.min.y;

      const resolveX = Math.min(overlapRight, overlapLeft);
      const resolveY = Math.min(overlapUp, overlapDown);

      if (resolveX < resolveY) {
        const rocketCenterX = (rocketCollider.min.x + rocketCollider.max.x) * 0.5;
        const platformCenterX = (collider.min.x + collider.max.x) * 0.5;
        if (deltaX > 0 || (deltaX === 0 && rocketCenterX >= platformCenterX)) {
          rocket.position.x -= resolveX;
        } else {
          rocket.position.x += resolveX;
        }
        rocketVelocity.x = 0;
      } else {
        const rocketCenterY = (rocketCollider.min.y + rocketCollider.max.y) * 0.5;
        const platformCenterY = (collider.min.y + collider.max.y) * 0.5;
        if (deltaY > 0 || (deltaY === 0 && rocketCenterY >= platformCenterY)) {
          rocket.position.y -= resolveY;
          if (rocketVelocity.y > 0) rocketVelocity.y = 0;
        } else {
          rocket.position.y += resolveY;
          rocketVelocity.y = 0;
          isGrounded = true;
        }
      }
      rocketCollider.setFromObject(rocket);
    }
  }

  function updateCamera() {
    if (!rocket) return;

    const targetX = rocket.position.x + cameraOffset.x;
    const targetY = rocket.position.y + cameraOffset.y;
    camera.position.x += (targetX - camera.position.x) * cameraLerpFactor;
    camera.position.y += (targetY - camera.position.y) * cameraLerpFactor;
    const desiredZ = getTargetCameraZ();
    camera.position.z += (desiredZ - camera.position.z) * cameraLerpFactor;

    camera.lookAt(
      rocket.position.x + cameraLookAtOffset.x,
      rocket.position.y + cameraLookAtOffset.y,
      rocket.position.z
    );

    if (stars) {
      stars.position.x = camera.position.x * 0.1;
      stars.position.y = camera.position.y * 0.05;
    }
  }

  function animate() {
    requestAnimationFrame(animate);
    updateRocket();
    updateCamera();
    renderer.render(scene, camera);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, pixelRatioLimit));
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.position.z = getTargetCameraZ();
  }

  init();
  animate();
</script>
</body>
</html>
